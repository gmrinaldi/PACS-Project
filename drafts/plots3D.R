#' Isosurface Plot of a FEMevaluated object
#' 
#' @param FEMevaluated A \code{FEMevaluated} object.
#' @param levels The levels at which the isosurfaces are generated. If levels is a vector, isosurfaces are generated for each level. The value of the levels has to be in the range of the possible \code{evaluated_values} of the \code{FEMevaluated} object.
#' @param ... Arguments representing  graphical options to be passed to \link[rgl]{plot3d}.
#' @description Isosurface plot of a \code{FEMevaluated} object, generated by the function \code{evaluate.grid.FEM}. This method is useful for plotting volumetric mesh (\code{MESH.3D}) objects.
#' @usage isosurfaces.FEMevaluated(FEMevaluated,levels,...)  
#' @seealso \code{\link{evaluate.grid.FEM}}
#' @examples 
#' ## Upload a tetrahedral mesh and plot it
#' data(sphere3D)
#' plot(sphere3D)
#' ##Define the number of nodes
#' nnodes=sphere3D$nnodes
#' ## Create a linear Finite Element basis
#' FEMbasis = create.FEM.basis(sphere3D)
#' ## Define a function as expansion of this basis
#' coeff=numeric(nnodes)
#' for(i in 0:nnodes-1){
#' 	coeff[i+1] <- 0.5*sqrt(15/pi)*sphere3D$nodes[i+1,1]*sphere3D$nodes[i+1,2]
#' }
#' FEM_object<- FEM(coeff, FEMbasis)
#' ##Create the grid of evaluated points
#' FEMevaluated=evaluate.grid.FEM(FEM_object)
#' ##Plot the isosurfaces
#' isosurfaces.FEMevaluated(FEMevaluated,levels=seq(-0.45,0.45,by=0.15))
isosurfaces.FEMevaluated<-function(FEMevaluated,levels,...)
{
  if(!require(plot3Drgl)){
    stop("The isosurfaces.FEMevaluated_function(...) requires the R package plot3Drgl,   please install it and try again!")
  }
  if (is.null(FEMevaluated)) 
    stop("FEMevaluated required;  is NULL.")
  if(class(FEMevaluated) != "FEMevaluated")
    stop("'FEMevaluated' is not of class 'FEMevaluated'")
  if (is.null(levels)) 
    stop("levels required;  is NULL.")
  
  ndata=length(FEMevaluated$evaluated_values)
  
  for(idata in 1:ndata)
  {
    isosurf3Drgl(x=FEMevaluated$x,y=FEMevaluated$y,z=FEMevaluated$z,colvar=FEMevaluated$evaluated_values[[idata]],level=levels,col=jet.col(length(levels),alpha=0.7), ...)
    axes3d()
    rgl.pop("lights") 
    light3d(specular="black")
    aspect3d("iso")
    rgl.viewpoint(0,-45)
    
    if (ndata > 1 && idata<ndata)
    {readline("Press a button for the next plot...")}
  }
} 


#' Slice Plot of a FEMevaluated object
#' 
#' @param FEMevaluated A \code{FEMevaluated} object.
#' @param xs Vector specifying the position in x where the slices(planes) has to be drawn. The values of \code{evaluated_values} of the \code{FEMevaluated} object are projected on these slices.
#' @param ys Vector specifying the position in y where the slices(planes) has to be drawn. The values of \code{evaluated_values} of the \code{FEMevaluated} object are projected on these slices.
#' @param zs Vector specifying the position in z where the slices(planes) has to be drawn. The values of \code{evaluated_values} of the \code{FEMevaluated} object are projected on these slices.
#' @param ... Arguments representing  graphical options to be passed to \link[rgl]{plot3d}.
#' @description Slice plot of a \code{FEMevaluated} object, generated by the function \code{evaluate.grid.FEM}. This method is useful for plotting volumetric mesh (\code{MESH.3D}) objects.
#' @usage slices.FEMevaluated(FEMevaluated,xs=0,ys=NULL,zs=NULL,...)  
#' @seealso \code{\link{evaluate.grid.FEM}}
#' @examples 
#' ## Upload a tetrahedral mesh and plot it
#' data(sphere3D)
#' plot(sphere3D)
#' ##Define the number of nodes
#' nnodes=sphere3D$nnodes
#' ## Create a linear Finite Element basis
#' FEMbasis = create.FEM.basis(sphere3D)
#' ## Define a function as expansion of this basis
#' coeff=numeric(nnodes)
#' for(i in 0:nnodes-1){
#' 	coeff[i+1] <- 0.5*sqrt(15/pi)*sphere3D$nodes[i+1,1]*sphere3D$nodes[i+1,2]
#' }
#' FEM_object<- FEM(coeff, FEMbasis)
#' ##Create the grid of evaluated points
#' FEMevaluated=evaluate.grid.FEM(FEM_object)
#' ##Plot the slices
#' slices.FEMevaluated(FEMevaluated,xs=c(-0.5,0,0.5),ys=c(-0.5,0,0.5),NAcol="transparent")

slices.FEMevaluated<-function(FEMevaluated,xs=0,ys=NULL,zs=NULL,...)
{
  if(!require(plot3Drgl)){
    stop("The isosurfaces.FEMevaluated_function(...) requires the R package plot3Drgl,   please install it and try again!")
  }
  if (is.null(FEMevaluated)) 
    stop("FEMevaluated required;  is NULL.")
  if(class(FEMevaluated) != "FEMevaluated")
    stop("'FEMevaluated' is not of class 'FEMevaluated'")
  
  ndata=length(FEMevaluated$evaluated_values)
  
  for(idata in 1:ndata)
  {
    slice3Drgl(x=FEMevaluated$x,y=FEMevaluated$y,z=FEMevaluated$z,colvar=FEMevaluated$evaluated_values[[idata]],xs=xs,ys=ys,zs=zs, ...)
    axes3d()
    rgl.pop("lights") 
    light3d(specular="black")
    aspect3d("iso")
    rgl.viewpoint(0,-45)
    
    if (ndata > 1 && idata<ndata)
    {readline("Press a button for the next plot...")}
  }
} 


#' Slice Contour Plot of a FEMevaluated object
#' 
#' @param FEMevaluated A \code{FEMevaluated} object.
#' @param xs Vector specifying the position in x where the slices(planes) has to be drawn. The values of \code{evaluated_values} of the \code{FEMevaluated} object are projected on these slices as contours.
#' @param ys Vector specifying the position in y where the slices(planes) has to be drawn. The values of \code{evaluated_values} of the \code{FEMevaluated} object are projected on these slices as contours.
#' @param zs Vector specifying the position in z where the slices(planes) has to be drawn. The values of \code{evaluated_values} of the \code{FEMevaluated} object are projected on these slices as contours.
#' @param ... Arguments representing  graphical options to be passed to \link[rgl]{plot3d}.
#' @description Slice contour plot of a \code{FEMevaluated} object, generated by the function \code{evaluate.grid.FEM}. This method is useful for plotting volumetric mesh (\code{MESH.3D}) objects.
#' @usage slicecontours.FEMevaluated(FEMevaluated,xs=0,ys=NULL,zs=NULL,...)  
#' @seealso \code{\link{evaluate.grid.FEM}}
#' @examples 
#' ## Upload a tetrahedral mesh and plot it
#' data(sphere3D)
#' plot(sphere3D)
#' ##Define the number of nodes
#' nnodes=sphere3D$nnodes
#' ## Create a linear Finite Element basis
#' FEMbasis = create.FEM.basis(sphere3D)
#' ## Define a function as expansion of this basis
#' coeff=numeric(nnodes)
#' for(i in 0:nnodes-1){
#' 	coeff[i+1] <- 0.5*sqrt(15/pi)*sphere3D$nodes[i+1,1]*sphere3D$nodes[i+1,2]
#' }
#' FEM_object<- FEM(coeff, FEMbasis)
#' ##Create the grid of evaluated points
#' FEMevaluated=evaluate.grid.FEM(FEM_object)
#' ##Plot the contour on the slices
#' slicecontours.FEMevaluated(FEMevaluated,xs=c(-0.5,0,0.5),ys=0,NAcol="blue")
slicecontours.FEMevaluated<-function(FEMevaluated,xs=0,ys=NULL,zs=NULL,...)
{
  if(!require(plot3Drgl)){
    stop("The isosurfaces.FEMevaluated_function(...) requires the R package plot3Drgl,   please install it and try again!")
  }
  if (is.null(FEMevaluated)) 
    stop("FEMevaluated required;  is NULL.")
  if(class(FEMevaluated) != "FEMevaluated")
    stop("'FEMevaluated' is not of class 'FEMevaluated'")
  
  ndata=length(FEMevaluated$evaluated_values)
  
  for(idata in 1:ndata)
  {
    slicecont3Drgl(x=FEMevaluated$x,y=FEMevaluated$y,z=FEMevaluated$z,colvar=FEMevaluated$evaluated_values[[idata]],xs=xs,ys=ys,zs=zs,border="white", ...)
    axes3d()
    rgl.pop("lights") 
    light3d(specular="black")
    aspect3d("iso")
    rgl.viewpoint(0,-45)
    
    if (ndata > 1 && idata<ndata)
    {readline("Press a button for the next plot...")}
  }
} 

#' Evaluate a FEM object at a grid of point locations
#' 
#' @param FEM A \code{FEM} object to be evaluated.
#' @param length_interval_x. An integer specifying the length of the interval on the x axis of the grid of points where the FEM object should be evaluated. Default value is 25.
#' @param length_interval_y. An integer specifying the length of the interval on the y axis of the grid of points where the FEM object should be evaluated. If no value is specified, the length is assumed to be equal to the \code{length_interval_x} parameter.
#' @param length_interval_z. An integer specifying the length of the interval on the z axis of the grid of points where the FEM object should be evaluated. If no value is specified, the length is assumed to be equal to the \code{length_interval_x} parameter.
#' @return 
#' An object of class \code{FEMevaluated} with the following output:
#' \item{\code{evaluated_values}}{A matrix of numeric evaluations of the \code{FEM} object. The element of the matrix corresponds to the locations of the elements of the meshgrid generated.}
#' \item{\code{meshgrid}}{The meshgrid generated using the specified intervals on the 3 axis.}
#' \item{\code{x}}{A vector of length \code{length_interval_x} containing the x coordinate for each point of the meshgrid generated.}
#' \item{\code{y}}{A vector of length \code{length_interval_y} containing the y coordinate for each point of the meshgrid generated.}
#' \item{\code{z}}{A vector of length \code{length_interval_z} containing the z coordinate for each point of the meshgrid generated.}
#' @description It evaluates a FEM object at a specified grid of point locations. It is needed for doing 3D plots like isosurface plot, slice plot and slicecontour plot.
#' @usage eval.FEM(FEM, length_interval_x=25, length_interval_y=NULL,length_interval_z=NULL, CPP_CODE=TRUE)
#' @seealso \code{\link{isosurfaces.FEMevaluated}},\code{\link{slices.FEMevaluated}} and \code{\link{slicecontours.FEMevaluated}}
#' @references 
#'  Devillers, O. et al. 2001. Walking in a Triangulation, Proceedings of the Seventeenth Annual Symposium on Computational Geometry

evaluate.grid.FEM <- function(FEM, length_interval_x=25, length_interval_y=NULL,length_interval_z=NULL)
{
  if(class(FEM$FEMbasis$mesh)!="MESH.3D")
    warning("This function is meant to be used for 3D meshes. You may want to use eval.FEM instead")
  if (is.null(FEM)) 
    stop("FEM required;  is NULL.")
  if(class(FEM) != "FEM")
    stop("'FEM' is not of class 'FEM'")
  if(is.null(length_interval_x))
    stop("length_interval_x required;is NULL.")
  if(is.null(length_interval_y))
    length_interval_y=length_interval_x
  if(is.null(length_interval_z))
    length_interval_z=length_interval_x
  
  
  nodes=FEM$FEMbasis$mesh$nodes
  x=seq(min(nodes[,1]),max(nodes[,1]),length.out=length_interval_x)
  y=seq(min(nodes[,2]),max(nodes[,2]),length.out=length_interval_y)
  z=seq(min(nodes[,3]),max(nodes[,3]),length.out=length_interval_z)
  
  M=mesh(x,y,z)
  
  loc=NULL
  for(i in 1:length_interval_x)
  {
    for(j in 1:length_interval_y)
    {
      for(k in 1:length_interval_z)
      {
        loc=rbind(loc,c(M$x[i,j,k],M$y[i,j,k],M$z[i,j,k]))
      }
    }
  }
  
  
  eval=eval.FEM(FEM=FEM,locations=loc)
  ndata=dim(eval)[2]
  
  evaluated_values=NULL
  
  for(idata in 1:ndata)
  {	name=paste("values",idata,sep="")
  values=array(data=NA,dim=c(length_interval_x,length_interval_y,length_interval_z))
  for(i in 1:length_interval_x)
  {
    for(j in 1:length_interval_y)
    {
      for(k in 1:length_interval_z)
      {
        values[i,j,k]=eval[length_interval_x^2*(i-1)+length_interval_y*(j-1)+k,idata]
      }
    }
  }
  evaluated_values[[idata]]=values
  names(evaluated_values)[idata]=name
  }
  
  
  reslist=list(evaluated_values=evaluated_values,meshgrid=M, x=x, y=y, z=z)
  class(reslist)="FEMevaluated"
  return (reslist)
}


