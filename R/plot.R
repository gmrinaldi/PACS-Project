#' Plot a \code{FEM} object
#'
#' @param FEMobject A \code{FEM} object.
#' @param num_refinements A natural number specifying how many bisections should be applied to each triangular element for
#' plotting purposes. This functionality is useful where a discretization with 2nd order Finite Element is applied.
#' This parameter can be specified only when a FEM object defined over a 2D mesh is plotted.
#' @param ... Arguments representing graphical options to be passed to \link[rgl]{plot3d}.
#' @description Three-dimensional plot of a \code{FEM} object, generated by \code{FEM} or returned by
#' \code{smooth.FEM} or \code{FPCA.FEM}.
#' If the \code{mesh} of the \code{FEMbasis} component is of class \code{mesh.2D} both the 3rd axis and the color represent
#' the value of the coefficients for the Finite Element basis expansion (\code{coeff} component of the \code{FEM} object).
#' If the \code{mesh} is of class \code{mesh.3D}, the color of each triangle or tetrahedron represent the mean value of
#' the coefficients for the Finite Element basis expansion (\code{coeff}).
#' @usage \method{plot}{FEM}(FEMobject, num_refinements, ...)
#' @export
#' @seealso \code{\link{FEM}}, \code{\link{image.FEM}}
#' @examples
#' library(fdaPDE)
#' ## Upload the horseshoe2D data
#' data(horseshoe2D)
#'
#' ## Create the 2D mesh
#' mesh = create.mesh.2D(nodes = rbind(boundary_nodes, locations), segments = boundary_segments)
#' ## Create the FEM basis
#' FEMbasis = create.FEM.basis(mesh)
#' ## Compute the coeff vector evaluating the desired function at the mesh nodes
#' ## In this case we consider the fs.test() function introduced by Wood et al. 2008
#' coeff = fs.test(mesh$nodes[,1], mesh$nodes[,2], exclude = FALSE)
#' ## Create the FEM object
#' FEMfunction = FEM(coeff, FEMbasis)
#'
#' ## Plot the FEM function
#' plot(FEMfunction)

plot.FEM <- function(FEMobject, num_refinements = NULL, ...)
{
   if(class(FEMobject$FEMbasis$mesh)=="mesh.2D"){
      if(FEMobject$FEMbasis$order == 1)
      {
         R_plot.ORD1.FEM(FEMobject, ...)
      }else{
         R_plot.ORDN.FEM(FEMobject, num_refinements, ...)
      }
   }else if(class(FEMobject$FEMbasis$mesh)=="mesh.2.5D"){
      R_plot_manifold(FEMobject,...)
   }else if(class(FEMobject$FEMbasis$mesh)=="mesh.3D"){
      R_plot_volume(FEMobject,...)
   }
}


#' Plot a mesh.2D object
#'
#' @param mesh A \code{mesh.2D} object defining the triangular mesh, as generated by \code{create.mesh.2D}
#' or \code{refine.mesh.2D}.
#' @param ... Arguments representing graphical options to be passed to \link[graphics]{par}.
#' @description Plot a mesh.2D object, generated by \code{create.mesh.2D} or \code{refine.mesh.2D}.
#' @name plot.mesh.2D

#' @usage \method{plot}{mesh.2D}(mesh, ...)
#' @export
#' @examples
#' library(fdaPDE)
#'
#' ## Upload the quasicirle2D data
#' data(quasicircle2D)
#' ## Create mesh
#' mesh = create.mesh.2D(nodes = rbind(boundary_nodes, locations), segments = boundary_segments)
#'
#' ## Plot the mesh
#' plot(mesh)
plot.mesh.2D<-function(mesh, ...)
{
   plot(mesh$nodes, xlab="", ylab="", xaxt="n", yaxt="n", bty="n", ...)
   segments(mesh$nodes[mesh$edges[,1],1], mesh$nodes[mesh$edges[,1],2],
            mesh$nodes[mesh$edges[,2],1], mesh$nodes[mesh$edges[,2],2], ...)
   segments(mesh$nodes[mesh$segments[,1],1], mesh$nodes[mesh$segments[,1],2],
            mesh$nodes[mesh$segments[,2],1], mesh$nodes[mesh$segments[,2],2], col="red", ...)
}
#' Plot a mesh.2.5D object
#'
#' @param mesh A \code{mesh.2.5D} object generated by \code{create.mesh.2.5D}.
#' @param ... Arguments representing graphical options to be passed to \link[graphics]{par}.
#' @description Plot the triangulation of a \code{mesh.2.5D} object, generated by \code{create.mesh.2.5D}
#' @export
#' @name plot.mesh.2.5D

#' @usage \method{plot}{mesh.2.5D}(mesh, ...)
#' @examples
#' library(fdaPDE)
#'
#' ## Upload the hub2.5D the data
#' data(hub2.5D)
#'
#' ## Create mesh
#' mesh = create.mesh.2.5D(nodes = hub2.5D.nodes, triangles = hub2.5D.triangles)
#' plot(mesh)


plot.mesh.2.5D<-function(mesh,...){
   
   nodes <- mesh$nodes
   edges <- as.vector(t(mesh$edges))
   
   open3d()
   axes3d()
   rgl.pop("lights")
   light3d(specular="black")
   
   rgl.points(nodes[,1], nodes[,2], nodes[,3], col="black", ...)
   rgl.lines(nodes[edges,1], nodes[edges,2], nodes[edges,3], col="black",...)
   
   aspect3d("iso")
   rgl.viewpoint(0,-45)
   
}

#' Plot a mesh.3D object
#'
#' @param mesh A \code{mesh.3D} object generated by \code{create.mesh.3D}.
#' @param ... Arguments representing graphical options to be passed to \link[graphics]{par}.
#' @description Plot a \code{mesh.3D} object, generated by \code{create.mesh.3D}.
#' @export
#' @name plot.mesh.3D

#' @usage \method{plot}{mesh.3D}(mesh, ...)
#' @examples
#' library(fdaPDE)
#'
#' ##Load a mesh.3D object
#' data(sphere3D)
#' ##Plot the triangulation of the object
#' plot.mesh.3D(sphere3D)


plot.mesh.3D<-function(mesh,...){
   
   nodes < -mesh$nodes
   faces <- as.vector(t(mesh$faces))
   
   open3d()
   axes3d()
   rgl.pop("lights")
   light3d(specular="black")
   
   rgl.triangles(nodes[faces,1],nodes[faces,2],nodes[faces,3],col="white",...)
   
   aspect3d("iso")
   rgl.viewpoint(0,-45)
   
}


R_plot.ORD1.FEM <- function(FEM, ...) {
   
   nodes <- FEM$FEMbasis$mesh$nodes
   triangles <- as.vector(t(FEM$FEMbasis$mesh$triangles))
   
   heat <- heat.colors(100)
   # How many plots are needed?
   nplots <- ncol(FEM$coeff)
   
   for (i in 1:nplots) {
      
      if (i > 1)
         readline("Press any key for the next plot...")
      
      open3d()
      axes3d()
      
      z <- FEM$coeff[triangles,i]
      rgl.triangles(nodes[triangles,1], nodes[triangles,2], z,
                    color = heat[round(99*(z-min(z))/diff(range(z)))+1],...)
      
      aspect3d(2,2,1)
      rgl.viewpoint(0,-45)
   }
}

R_plot.ORDN.FEM <- function(FEM, num_refinements=10, ...){
   # num_refinements sets the number of subdivisions on each triangle edge to be applied for refinement
   if(!(FEM$FEMbasis$order %in% c(1,2)))
      stop('ORDER has to be either 1 or 2.')
   
   mesh <- FEM$FEMbasis$mesh
   num_elements <- nrow(mesh$triangles)
   
   # For the reference triangles we construct a regular mesh
   x <- seq(from = 0, to = 1, length.out = num_refinements+1)
   points_ref <- expand.grid(x,x)
   points_ref <- points_ref[rowSums(points_ref)<=1,]
   
   reference_mesh <- create.mesh.2D(nodes = points_ref, order = 1)
   num_points <- nrow(reference_mesh$nodes)
   
   points <- do.call(rbind,lapply(FEMbasis$transf_coord, function(x){
      reference_mesh$nodes%*%t(x)
   }))
   
   # locations is the matrix with that will contain the coordinate of the points where the function is evaluated
   locations <- points + mesh$nodes[mesh$triangles[rep(1:num_elements,each=num_points),1],]
   
   # evaluate the function
   evals <- do.call(rbind,lapply(seq_len(num_elements),function(i){
      R_eval_local.FEM(FEM, locations = locations[(i-1)*num_points+seq_len(num_points),], element_index = i)
   }))
   
   # First the triangles matrix for the reference mesh is copy-pasted num_elements times
   # Then we add to each column the right offset
   triangles <- reference_mesh$triangles[rep.int(1:nrow(reference_mesh$triangles), num_elements),] +
      num_points*rep(0:(num_elements-1), each=nrow(reference_mesh$triangles))
   
   triangles <- as.vector(t(triangles))
   heat <- heat.colors(100)
   
   nplots <- ncol(FEM$coeff)
   
   for (i in 1:nplots){
      if (i > 1)
         readline("Press any key for the next plot...")
      
      open3d()
      axes3d()
      rgl.pop("lights")
      light3d(specular="black")
      z <- evals[triangles,i]
      rgl.triangles(locations[triangles,1], locations[triangles,2], z,
                    color = heat[round(99*(z-min(z))/diff(range(z)))+1],...)
      aspect3d(2,2,1)
      rgl.viewpoint(0,-45)
   }
}

R_plot_manifold <- function(FEM, ...){
   
   nodes <- FEM$FEMbasis$mesh$nodes
   triangles <- as.vector(t(FEM$FEMbasis$mesh$triangles))
   edges <- as.vector(t(FEM$FEMbasis$mesh$edges))
   coeff <- FEM$coeff
   
   p <- jet.col(n=128,alpha=0.8)
   palette(p)
   ncolor <- length(p)
   
   nplots <- ncol(coeff)
   
   for (i in 1:nplots){
      if (i > 1)
         readline("Press any key for the next plot...")
      
      open3d()
      axes3d()
      rgl.pop("lights")
      light3d(specular="black")
      
      col <- coeff[triangles,i]
      col <- (ncolor-1)*(col-min(col))/diff(range(col))+1
      col <- p[col]
      
      rgl.triangles(nodes[triangles,1], nodes[triangles,2],
                    nodes[triangles,3], color = col,...)
      rgl.lines(nodes[edges,1], nodes[edges,2], nodes[edges,3],
                color = "black",...)
      aspect3d("iso")
      rgl.viewpoint(0,-45)
   }
}


R_plot_volume <- function(FEM,...){
   # 
   nodes <- FEM$FEMbasis$mesh$nodes
   faces <- as.vector(t(FEM$FEMbasis$mesh$faces[as.logical(FEM$FEMbasis$mesh$facesmarkers),]))
   edges <- as.vector(t(FEM$FEMbasis$mesh$edges[as.logical(FEM$FEMbasis$mesh$edgesmarkers),]))
   coeff <- FEM$coeff
   
   p <- jet.col(n=128,alpha=0.8)
   palette(p)
   ncolor <- length(p)
   
   nplots <- ncol(FEM$coeff)
   
   for (i in 1:nplots){
      if (i > 1)
         readline("Press any key for the next plot...")
      
      open3d()
      axes3d()
      rgl.pop("lights")
      light3d(specular="black")
      
      col <- coeff[faces,i]
      col <- (ncolor-1)*(col-min(col))/diff(range(col))+1
      col <- p[col]
      
      rgl.triangles(nodes[faces,1], nodes[faces,2],
                    nodes[faces,3], color = col,...)
      rgl.lines(nodes[edges,1], nodes[edges,2], nodes[edges,3],
                color = "black",...)
      aspect3d("iso")
      rgl.viewpoint(0,-45)
   }
}

#' Image Plot of a 2D FEM object
#'
#' @param mesh A 2D-mesh \code{FEM} object.
#' @param num_refinements A natural number specifying how many bisections should by applied to each triangular element for
#' plotting purposes. This functionality is useful where a discretization with 2nd order Finite Element is applied.
#' @param ... Arguments representing  graphical options to be passed to \link[rgl]{plot3d}.
#' @description Image plot of a \code{FEM} object, generated by the function \code{FEM} or returned by
#' \code{smooth.FEM} and \code{FPCA.FEM}. Only FEM objects defined over a 2D mesh can be plotted with this method.
#' @usage \method{image}{FEM}(mesh, num_refinements, ...)
#' @seealso \code{\link{FEM}} \code{\link{plot.FEM}}
#' @export
#' @examples
#' library(fdaPDE)
#' ## Upload the horseshoe2D data
#' data(horseshoe2D)
#'
#' ## Create the 2D mesh
#' mesh = create.mesh.2D(nodes = rbind(boundary_nodes, locations), segments = boundary_segments)
#' ## Create the FEM basis
#' FEMbasis = create.FEM.basis(mesh)
#' ## Compute the coeff vector evaluating the desired function at the mesh nodes
#' ## In this case we consider the fs.test() function introduced by Wood et al. 2008
#' coeff = fs.test(mesh$nodes[,1], mesh$nodes[,2], exclude = FALSE)
#' ## Create the FEM object
#' FEMfunction = FEM(coeff, FEMbasis)
#'
#' ## Plot the FEM function
#' image(FEMfunction)
image.FEM <- function(mesh, num_refinements = NULL, ...)
{
   if(class(mesh$FEMbasis$mesh)!='mesh.2D')
      stop('This function is implemented only for 2D mesh FEM objects')
   
   if(mesh$FEMbasis$order == 1)
   {
      R_image.ORD1.FEM(mesh, ...)
   }else{
      R_image.ORDN.FEM(mesh, num_refinements, ...)
   }
}


R_image.ORD1.FEM = function(FEM){
   nodes <- FEM$FEMbasis$mesh$nodes
   triangles <- as.vector(t(FEM$FEMbasis$mesh$triangles))
   
   heat <- heat.colors(100)
   # How many plots are needed?
   nplots <- ncol(FEM$coeff)
   
   for (i in 1:nplots) {
      
      if (i > 1)
         readline("Press any key for the next plot...")
      
      open3d()
      axes3d()
      rgl.pop("lights") 
      light3d(specular="black") 
      
      z <- FEM$coeff[triangles,i]
      rgl.triangles(nodes[triangles,1], nodes[triangles,2], 0,
                    color = heat[round(99*(z-min(z))/diff(range(z)))+1])
      
      aspect3d(2,2,1)
      rgl.viewpoint(0,0)
   }
}

R_image.ORDN.FEM <- function(FEM, num_refinements){
   # num_refinements sets the number of subdivisions on each triangle edge to be applied for refinement
   if(!(FEM$FEMbasis$order %in% c(1,2)))
      stop('ORDER has to be either 1 or 2.')
   
   mesh <- FEM$FEMbasis$mesh
   num_elements <- nrow(mesh$triangles)
   
   # For the reference triangles we construct a regular mesh
   x <- seq(from = 0, to = 1, length.out = num_refinements+1)
   points_ref <- expand.grid(x,x)
   points_ref <- points_ref[rowSums(points_ref)<=1,]
   
   reference_mesh <- create.mesh.2D(nodes = points_ref, order = 1)
   num_points <- nrow(reference_mesh$nodes)
   
   points <- do.call(rbind,lapply(FEMbasis$transf_coord, function(x){
      reference_mesh$nodes%*%t(x)
   }))
   
   # locations is the matrix with that will contain the coordinate of the points where the function is evaluated
   locations <- points + mesh$nodes[mesh$triangles[rep(1:num_elements,each=num_points),1],]
   
   # evaluate the function
   evals <- do.call(rbind,lapply(seq_len(num_elements),function(i){
      R_eval_local.FEM(FEM, locations = locations[(i-1)*num_points+seq_len(num_points),], element_index = i)
   }))
   
   # First the triangles matrix for the reference mesh is copy-pasted num_elements times
   # Then we add to each column the right offset
   triangles <- reference_mesh$triangles[rep.int(1:nrow(reference_mesh$triangles), num_elements),] +
      num_points*rep(0:(num_elements-1), each=nrow(reference_mesh$triangles))
   
   triangles <- as.vector(t(triangles))
   heat <- heat.colors(100)
   
   nplots <- ncol(FEM$coeff)
   
   for (i in 1:nplots){
      if (i > 1)
         readline("Press any key for the next plot...")
      
      open3d()
      axes3d()
      rgl.pop("lights")
      light3d(specular="black")
      z <- evals[triangles,i]
      rgl.triangles(locations[triangles,1], locations[triangles,2], 0,
                    color = heat[round(99*(z-min(z))/diff(range(z)))+1])
      aspect3d(2,2,1)
      rgl.viewpoint(0,0)
   }
}


R_eval_local.FEM <- function(FEM, locations, element_index)
{
   num_points<-nrow(locations)
   # Augment locations matrix with a column made of 1s for computing barycentric coordinates
   Pgpts = cbind(1,locations)
   
   # Get nodes and index
   nodes <- FEM$FEMbasis$mesh$nodes
   triangles <- FEM$FEMbasis$mesh$triangles
   
   # 3x2 matrix of vertices of triangles
   
   vertices<-nodes[triangles[element_index,],]
   
   # Denominator of change of coordinates chsange matrix
   
   modJ <- FEM$FEMbasis$detJ[element_index]
   
   v231<-vertices[c(2,3,1),]
   v312<-vertices[c(3,1,2),]
   coord_change <- cbind(v231[,1]*v312[,2]-v312[,1]*v231[,2], v231[,2]-v312[,2], v312[,1]-v231[,1])/modJ
   
   baryc <- coord_change%*%t(Pgpts)

   if(FEM$FEMbasis$order==2){
      baryc <- rbind(baryc,4*baryc)*rbind(2*baryc-1,baryc[c(2,3,1),])
      evalmat <- t(baryc) %*% FEM$coeff[triangles[element_index,c(1:3,6,4,5)],]
   }else{
      evalmat <- t(baryc) %*% FEM$coeff[triangles[element_index,1:3],]
   }
   return(evalmat)
}
